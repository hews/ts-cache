"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _types = require("./types");

var _LinkedList = _interopRequireWildcard(require("./utils/LinkedList"));

var _Timestamp = _interopRequireDefault(require("./utils/Timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// DefaultAdapter acts as a thin wrapper around a native Map object,
// implementing the basic Cache interface with some added options for
// calculating the cache's memory pressure ("usage"/"size") and
// handling expiration (returning "stale" entries and resetting TTLs).
//
// TODO: [PJ] implement CacheConstructor on the static interface for the
// class. Not sure if the difficulties in using the class expression:
//
//   const Cache: CacheConstructor = class Cache implements Cache { ... }
//
// ... arise from a lexical inability to deal with generics for the
// static interface, a bug, or my own (probably) inability to wrap my
// head around the syntax.
//
// Example here: https://www.typescriptlang.org/docs/handbook/interfaces.html#difference-between-the-static-and-instance-sides-of-classes
//
class DefaultAdapter {
  constructor(opts = {}) {
    var _opts$size, _opts$ttl, _opts$dispose, _opts$disposeOnUpdate, _opts$evictionPolicy, _opts$entrySize, _opts$stale, _opts$resetTTL;

    _defineProperty(this, "map", new Map());

    _defineProperty(this, "lru", new _LinkedList.default());

    _defineProperty(this, "ins", new _LinkedList.default());

    _defineProperty(this, "evictionPolicy", void 0);

    _defineProperty(this, "ttl", void 0);

    _defineProperty(this, "size", void 0);

    _defineProperty(this, "used", 0);

    _defineProperty(this, "disposeOnUpdate", void 0);

    _defineProperty(this, "stale", void 0);

    _defineProperty(this, "resetTTL", void 0);

    _defineProperty(this, "entrySize", void 0);

    _defineProperty(this, "dispose", void 0);

    this.size = (_opts$size = opts.size) !== null && _opts$size !== void 0 ? _opts$size : Infinity;
    this.ttl = (_opts$ttl = opts.ttl) !== null && _opts$ttl !== void 0 ? _opts$ttl : Infinity;
    this.dispose = (_opts$dispose = opts.dispose) !== null && _opts$dispose !== void 0 ? _opts$dispose : () => {};
    this.disposeOnUpdate = (_opts$disposeOnUpdate = opts.disposeOnUpdate) !== null && _opts$disposeOnUpdate !== void 0 ? _opts$disposeOnUpdate : true;
    this.evictionPolicy = (_opts$evictionPolicy = opts.evictionPolicy) !== null && _opts$evictionPolicy !== void 0 ? _opts$evictionPolicy : _types.CacheEvictionPolicies.LRU;
    this.entrySize = (_opts$entrySize = opts.entrySize) !== null && _opts$entrySize !== void 0 ? _opts$entrySize : () => 1;
    this.stale = (_opts$stale = opts.stale) !== null && _opts$stale !== void 0 ? _opts$stale : false;
    this.resetTTL = (_opts$resetTTL = opts.resetTTL) !== null && _opts$resetTTL !== void 0 ? _opts$resetTTL : true;
  }

  set(key, value, {
    ttl = Infinity
  } = {}) {
    const inserted = new _Timestamp.default();
    const touched = new _Timestamp.default();
    const lruNode = new _LinkedList.LinkedListNode();
    const insNode = new _LinkedList.LinkedListNode();
    const entry = {
      ttl,
      value,
      inserted,
      touched,
      lruNode,
      insNode
    };
    lruNode.data = entry;
    insNode.data = entry;
    const prev = this.map.get(key);

    if (prev && this.disposeOnUpdate) {
      // NOTE: [PJ] since pushing an existing node also removes it, we
      // can assume that happens below.
      this.dispose(key, prev.value);
    }

    this.evict(this.entrySize(entry));
    this.map.set(key, entry);
    this.lru.pushNode(lruNode);
    this.ins.pushNode(insNode);
    return prev === null || prev === void 0 ? void 0 : prev.value;
  }

  get(key, {
    peek = false,
    entry: returnEntry = false,
    stale = false
  } = {}) {
    const entry = this.map.get(key);

    if (entry === undefined) {
      return undefined;
    }

    const ts = this.resetTTL ? entry.inserted : entry.touched;
    const ttl = entry.ttl ? entry.ttl : this.ttl;

    if (ts.hasPassed(ttl)) {
      this.del(key);
      return stale ? entry.value : undefined;
    }

    if (!peek) {
      this.touch(entry);
    }

    return returnEntry ? entry : entry.value;
  }

  has(key, {
    peek = false
  } = {}) {
    const entry = this.map.get(key);

    if (entry === undefined) {
      return false;
    }

    if (!peek) {
      this.touch(entry);
    }

    return true;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  del(key, opts = {}) {
    const entry = this.map.get(key);

    if (entry === undefined) {
      return undefined;
    }

    this.dispose(key, entry);
    this.lru.removeNode(entry.lruNode);
    this.ins.removeNode(entry.insNode);
    this.map.delete(key);
    return entry.value;
  }

  aset(key, value, opts = {}) {
    return Promise.resolve(this.set(key, value, opts));
  }

  aget(key, opts = {}) {
    return Promise.resolve(this.get(key, opts));
  }

  ahas(key, opts = {}) {
    return Promise.resolve(this.has(key, opts));
  }

  adel(key, opts = {}) {
    return Promise.resolve(this.del(key, opts));
  }

  touch(entry) {
    entry.touched = new _Timestamp.default();
    this.lru.pushNode(entry.lruNode);
  } // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars


  evict(size) {// ...
  }

}

exports.default = DefaultAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EZWZhdWx0QWRhcHRlci50cyJdLCJuYW1lcyI6WyJEZWZhdWx0QWRhcHRlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsIk1hcCIsIkxpbmtlZExpc3QiLCJzaXplIiwiSW5maW5pdHkiLCJ0dGwiLCJkaXNwb3NlIiwiZGlzcG9zZU9uVXBkYXRlIiwiZXZpY3Rpb25Qb2xpY3kiLCJDYWNoZUV2aWN0aW9uUG9saWNpZXMiLCJMUlUiLCJlbnRyeVNpemUiLCJzdGFsZSIsInJlc2V0VFRMIiwic2V0Iiwia2V5IiwidmFsdWUiLCJpbnNlcnRlZCIsIlRpbWVzdGFtcCIsInRvdWNoZWQiLCJscnVOb2RlIiwiTm9kZSIsImluc05vZGUiLCJlbnRyeSIsImRhdGEiLCJwcmV2IiwibWFwIiwiZ2V0IiwiZXZpY3QiLCJscnUiLCJwdXNoTm9kZSIsImlucyIsInBlZWsiLCJyZXR1cm5FbnRyeSIsInVuZGVmaW5lZCIsInRzIiwiaGFzUGFzc2VkIiwiZGVsIiwidG91Y2giLCJoYXMiLCJyZW1vdmVOb2RlIiwiZGVsZXRlIiwiYXNldCIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWdldCIsImFoYXMiLCJhZGVsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7O0FBY0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxNQUFNQSxjQUFOLENBQ21CO0FBeUJoQ0MsRUFBQUEsV0FBVyxDQUFDQyxJQUErQyxHQUFHLEVBQW5ELEVBQXVEO0FBQUE7O0FBQUEsaUNBeEIxQyxJQUFJQyxHQUFKLEVBd0IwQzs7QUFBQSxpQ0F0QnRDLElBQUlDLG1CQUFKLEVBc0JzQzs7QUFBQSxpQ0FwQnRDLElBQUlBLG1CQUFKLEVBb0JzQzs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQSxrQ0FabkQsQ0FZbUQ7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7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SUFBSSxDQUNGM0IsR0FERSxFQUVGQyxLQUZFLEVBR0ZoQixJQUE4QixHQUFHLEVBSC9CLEVBSXNCO0FBQ3hCLFdBQU8yQyxPQUFPLENBQUNDLE9BQVIsQ0FBZ0IsS0FBSzlCLEdBQUwsQ0FBU0MsR0FBVCxFQUFjQyxLQUFkLEVBQXFCaEIsSUFBckIsQ0FBaEIsQ0FBUDtBQUNEOztBQUVENkMsRUFBQUEsSUFBSSxDQUNGOUIsR0FERSxFQUVGZixJQUF1QyxHQUFHLEVBRnhDLEVBR2lDO0FBQ25DLFdBQU8yQyxPQUFPLENBQUNDLE9BQVIsQ0FBZ0IsS0FBS2pCLEdBQUwsQ0FBU1osR0FBVCxFQUFjZixJQUFkLENBQWhCLENBQVA7QUFDRDs7QUFFRDhDLEVBQUFBLElBQUksQ0FBQy9CLEdBQUQsRUFBU2YsSUFBOEIsR0FBRyxFQUExQyxFQUFnRTtBQUNsRSxXQUFPMkMsT0FBTyxDQUFDQyxPQUFSLENBQWdCLEtBQUtMLEdBQUwsQ0FBU3hCLEdBQVQsRUFBY2YsSUFBZCxDQUFoQixDQUFQO0FBQ0Q7O0FBRUQrQyxFQUFBQSxJQUFJLENBQUNoQyxHQUFELEVBQVNmLElBQThCLEdBQUcsRUFBMUMsRUFBc0U7QUFDeEUsV0FBTzJDLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQixLQUFLUCxHQUFMLENBQVN0QixHQUFULEVBQWNmLElBQWQsQ0FBaEIsQ0FBUDtBQUNEOztBQUVEc0MsRUFBQUEsS0FBSyxDQUFDZixLQUFELEVBQXdCO0FBQzNCQSxJQUFBQSxLQUFLLENBQUNKLE9BQU4sR0FBZ0IsSUFBSUQsa0JBQUosRUFBaEI7QUFDQSxTQUFLVyxHQUFMLENBQVNDLFFBQVQsQ0FBa0JQLEtBQUssQ0FBQ0gsT0FBeEI7QUFDRCxHQWxKK0IsQ0FvSmhDOzs7QUFDQVEsRUFBQUEsS0FBSyxDQUFDekIsSUFBRCxFQUFxQixDQUN4QjtBQUNEOztBQXZKK0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnRcbiAgICBuby1wYXJhbS1yZWFzc2lnbjogW1wiZXJyb3JcIiwgeyBcInByb3BzXCI6IHRydWUsIFwiaWdub3JlUHJvcGVydHlNb2RpZmljYXRpb25zRm9yXCI6IFtcImVudHJ5XCJdIH1dICovXG5cbmltcG9ydCB7XG4gIENhY2hlSW50ZXJmYWNlLFxuICBDYWNoZUNvbnN0cnVjdG9yT3B0aW9ucyxcbiAgQ2FjaGVLZXkgYXMgS2V5LFxuICBDYWNoZVZhbHVlIGFzIFZhbCxcbiAgQ2FjaGVFbnRyeSxcbiAgQ2FjaGVTZXRPcHRpb25zLFxuICBDYWNoZUdldE9wdGlvbnMsXG4gIENhY2hlSGFzT3B0aW9ucyxcbiAgQ2FjaGVEZWxPcHRpb25zLFxuICBQb3NpdGl2ZU51bWJlcixcbiAgRGlzcG9zZUNiLFxuICBDYWNoZUV2aWN0aW9uUG9saWNpZXMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IExpbmtlZExpc3QsIHsgTGlua2VkTGlzdE5vZGUgYXMgTm9kZSB9IGZyb20gJy4vdXRpbHMvTGlua2VkTGlzdCc7XG5pbXBvcnQgVGltZXN0YW1wIGZyb20gJy4vdXRpbHMvVGltZXN0YW1wJztcblxuLy8gRGVmYXVsdEFkYXB0ZXJFbnRyeSBleHBhbmRzIHRoZSBkZWZhdWx0IENhY2hlRW50cnkgd2l0aCBuZWNlc3Nhcnlcbi8vIG1ldGFkYXRhIGZvciBUVEwgYW5kIGV2aWN0aW9uLlxuLy9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdEFkYXB0ZXJFbnRyeTxWPiBleHRlbmRzIENhY2hlRW50cnk8Vj4ge1xuICB0dGw6IG51bWJlcjtcbiAgaW5zZXJ0ZWQ6IFRpbWVzdGFtcDtcbiAgdG91Y2hlZDogVGltZXN0YW1wO1xuICBscnVOb2RlOiBOb2RlPERlZmF1bHRBZGFwdGVyRW50cnk8Vj4+O1xuICBpbnNOb2RlOiBOb2RlPERlZmF1bHRBZGFwdGVyRW50cnk8Vj4+O1xufVxudHlwZSBFbnRyeTxWPiA9IERlZmF1bHRBZGFwdGVyRW50cnk8Vj47IC8vIEVhc3kuXG5cbi8vIERlZmF1bHRBZGFwdGVyR2V0T3B0aW9ucyBleHBhbmRzIENhY2hlR2V0T3B0aW9ucyB3aXRoIGEgc3RhbGUgcGFyYW0uXG4vL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0QWRhcHRlckdldE9wdGlvbnMgZXh0ZW5kcyBDYWNoZUdldE9wdGlvbnMge1xuICAvLyBJbiB0aGUgY2FzZSB0aGF0IHRoZSBhY2Nlc3NlZCB2YWx1ZSBoYXMgZXhwaXJlZCwgdGhpcyBpbnN0cnVjdHMgdGhlXG4gIC8vIGdldCB0byByZXR1cm4gdGhlIChzdGFsZSkgdmFsdWUgYmVmb3JlIGRpc3Bvc2luZyBvZiBpdC5cbiAgc3RhbGU6IGJvb2xlYW47XG59XG5cbi8vIEVudHJ5U2l6ZUNiIGlzIHRoZSBzaWduYXR1cmUgb2YgZW50cnktc2l6ZSBjYWxjdWxhdGlvbiBjYWxsYmFja3MuXG4vL1xuZXhwb3J0IHR5cGUgRW50cnlTaXplQ2IgPSAoZW50cnk6IEVudHJ5PFZhbD4pID0+IFBvc2l0aXZlTnVtYmVyO1xuXG4vLyBEZWZhdWx0QWRhcHRlckNvbnN0cnVjdG9yT3B0aW9ucyBleHBhbmRzIENhY2hlQ29uc3RydWN0b3JPcHRpb25zIHdpdGhcbi8vIHBhcmFtdGVycyBmb3IgaW5zdGFudGlhdGluZyBhbmQgdHVuaW5nIHRoZSBEZWZhdWx0QWRhcHRlci4gRm9yIHVzZSBieVxuLy8gaHVtYW4gcGVvcGxlIGl0J3MgcGFydGlhbCBpbnRlcmZhY2UgaXMgYWxpYXNlZCBhcyBEZWZhdWx0T3B0cy5cbi8vXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRBZGFwdGVyQ29uc3RydWN0b3JPcHRpb25zXG4gIGV4dGVuZHMgQ2FjaGVDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICAvLyBUaGlzIGFkYXB0ZXIgZG9lcyBub3QgcHJvdmlkZSBhIGZhY2lsaXR5IGZvciBtZWFzdXJpbmcgdGhlIHNpemUgb2ZcbiAgLy8gc3RvcmVkIGVudHJpZXMuIFRoZXJlZm9yZSB3ZSBtdXN0IGRlZmluZSB0aGUgKG1heCkgc2l6ZSBpbiB0ZXJtcyBvZlxuICAvLyBzb21lIGFic3RyYWN0IHZhbHVlLCBhbmQgdGhlbiB3ZSBjYW4gc2V0IGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlXG4gIC8vIHRoZSByZWxhdGl2ZSBzaXplIG9mIGVhY2ggZW50cnkgYW5kIHRyYWNrIHRoZSB1c2VkIHNpemUgZm9yXG4gIC8vIGRldGVybWluaW5nIGV2aWN0aW9ucy5cbiAgLy9cbiAgLy8gVGhlIHNpbXBsZXN0IChhbmQgZGVmYXVsdCkgYWxnb3JpdGhtIGlzIHRvIGRlZmluZSB0aGUgbWF4IHNpemUgYXNcbiAgLy8gXCJtYXggbnVtYmVyIG9mIGVudHJpZXMsXCIgYW5kIHRoZSBlbnRyeVNpemUgY2FsbGJhY2sgYXMgcmV0dXJuaW5nXG4gIC8vIFwiMVwiLCBpZSBcInRoaXMgaXMgYSBzaW5nbGUgZW50cnkuXCJcbiAgLy9cbiAgLy8gSWYgeW91J3JlIHN0b3Jpbmcgc3RyaW5ncyBvciBidWZmZXJzLCB0aGVuIHlvdSBwcm9iYWJseSB3YW50IHRvIGRvXG4gIC8vIHNvbWV0aGluZyBsaWtlIChrZXksIHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGguXG4gIGVudHJ5U2l6ZTogRW50cnlTaXplQ2I7XG5cbiAgLy8gV2hpbGUgdGhlIGJlaGF2aW9yIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBwdWJsaWMgQVBJLCB0aGlzIGFkYXB0ZXJcbiAgLy8gcmVtb3ZlcyBleHBpcmVkIGVudHJpZXMgbGF6aWx5LCBpZSwgb25seSBvbmNlIHRoZXkgYXJlIGFjY2Vzc2VkIGJ5IGFcbiAgLy8gcmVhZCBvcGVyYXRpb246IGdldCgpIG9yIGhhcygpLiBUaGlzIG1lYW5zIHRoYXQgeW91IGNhbiBoYXZlIGEgd2hvbGVcbiAgLy8gYnVuY2gganVzdCBseWluZyBhcm91bmQsIHRha2luZyB1cCBzcGFjZS5cbiAgLy9cbiAgLy8gQnV0IGl0IGFsc28gbWVhbnMgdGhhdCB3ZSBjYW4gY2hvb3NlIHRvIHB1bGwgc3RhbGUgaXRlbXMgKGl0ZW1zIHRoYXRcbiAgLy8gaGF2ZSBleHBpcmVkKSBhbmQgcmV0dXJuIHRoZW0gYmVmb3JlIGRlbGV0aW5nIHRoZW0uIFBhc3NpbmcgdGhlXG4gIC8vIHN0YWxlIG9wdGlvbiBvbiBjb25zdHJ1Y3Rpb24gbWVhbnMgeW91IHdhbnQgdG8gaW1wbGVtZW50IHRoaXNcbiAgLy8gYmVoYXZpb3IgYnkgZGVmYXVsdC5cbiAgLy9cbiAgLy8gT25seSBnZXQoKSBpcyBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbi4gaGFzKCkgd2lsbCBuZXZlciByZXR1cm4gdHJ1ZVxuICAvLyBmb3IgYW4gZXhwaXJlZCBpdGVtLlxuICBzdGFsZTogYm9vbGVhbjtcblxuICAvLyBXaGVuIHVzaW5nIGEgVFRMIHdpdGggZW50aXJlcywgdGhlIHJlc2V0VFRMIG9wdGlvbiBjYXVzZXMgdGhlIFRUTFxuICAvLyB0byByZXNldCBvbiBhbnkgcmVhZCBvcGVyYXRpb246IGdldCgpIG9yIGhhcygpLlxuICByZXNldFRUTDogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIERlZmF1bHRPcHRzID0gUGFydGlhbDxEZWZhdWx0QWRhcHRlckNvbnN0cnVjdG9yT3B0aW9ucz47XG5cblxuLy8gRGVmYXVsdEFkYXB0ZXIgYWN0cyBhcyBhIHRoaW4gd3JhcHBlciBhcm91bmQgYSBuYXRpdmUgTWFwIG9iamVjdCxcbi8vIGltcGxlbWVudGluZyB0aGUgYmFzaWMgQ2FjaGUgaW50ZXJmYWNlIHdpdGggc29tZSBhZGRlZCBvcHRpb25zIGZvclxuLy8gY2FsY3VsYXRpbmcgdGhlIGNhY2hlJ3MgbWVtb3J5IHByZXNzdXJlIChcInVzYWdlXCIvXCJzaXplXCIpIGFuZFxuLy8gaGFuZGxpbmcgZXhwaXJhdGlvbiAocmV0dXJuaW5nIFwic3RhbGVcIiBlbnRyaWVzIGFuZCByZXNldHRpbmcgVFRMcykuXG4vL1xuLy8gVE9ETzogW1BKXSBpbXBsZW1lbnQgQ2FjaGVDb25zdHJ1Y3RvciBvbiB0aGUgc3RhdGljIGludGVyZmFjZSBmb3IgdGhlXG4vLyBjbGFzcy4gTm90IHN1cmUgaWYgdGhlIGRpZmZpY3VsdGllcyBpbiB1c2luZyB0aGUgY2xhc3MgZXhwcmVzc2lvbjpcbi8vXG4vLyAgIGNvbnN0IENhY2hlOiBDYWNoZUNvbnN0cnVjdG9yID0gY2xhc3MgQ2FjaGUgaW1wbGVtZW50cyBDYWNoZSB7IC4uLiB9XG4vL1xuLy8gLi4uIGFyaXNlIGZyb20gYSBsZXhpY2FsIGluYWJpbGl0eSB0byBkZWFsIHdpdGggZ2VuZXJpY3MgZm9yIHRoZVxuLy8gc3RhdGljIGludGVyZmFjZSwgYSBidWcsIG9yIG15IG93biAocHJvYmFibHkpIGluYWJpbGl0eSB0byB3cmFwIG15XG4vLyBoZWFkIGFyb3VuZCB0aGUgc3ludGF4LlxuLy9cbi8vIEV4YW1wbGUgaGVyZTogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50ZXJmYWNlcy5odG1sI2RpZmZlcmVuY2UtYmV0d2Vlbi10aGUtc3RhdGljLWFuZC1pbnN0YW5jZS1zaWRlcy1vZi1jbGFzc2VzXG4vL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmYXVsdEFkYXB0ZXI8SyBleHRlbmRzIEtleSwgViBleHRlbmRzIFZhbD5cbiAgaW1wbGVtZW50cyBDYWNoZUludGVyZmFjZTxLLCBWPiB7XG4gIG1hcDogTWFwPEssIEVudHJ5PFY+PiA9IG5ldyBNYXAoKTtcblxuICBscnU6IExpbmtlZExpc3Q8RW50cnk8Vj4+ID0gbmV3IExpbmtlZExpc3Q8RW50cnk8Vj4+KCk7XG5cbiAgaW5zOiBMaW5rZWRMaXN0PEVudHJ5PFY+PiA9IG5ldyBMaW5rZWRMaXN0PEVudHJ5PFY+PigpO1xuXG4gIGV2aWN0aW9uUG9saWN5OiBDYWNoZUV2aWN0aW9uUG9saWNpZXM7XG5cbiAgdHRsOiBudW1iZXI7XG5cbiAgc2l6ZTogbnVtYmVyO1xuXG4gIHVzZWQ6IG51bWJlciA9IDA7XG5cbiAgZGlzcG9zZU9uVXBkYXRlOiBib29sZWFuO1xuXG4gIHN0YWxlOiBib29sZWFuO1xuXG4gIHJlc2V0VFRMOiBib29sZWFuO1xuXG4gIGVudHJ5U2l6ZTogRW50cnlTaXplQ2I7XG5cbiAgZGlzcG9zZTogRGlzcG9zZUNiO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IFBhcnRpYWw8RGVmYXVsdEFkYXB0ZXJDb25zdHJ1Y3Rvck9wdGlvbnM+ID0ge30pIHtcbiAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgPz8gSW5maW5pdHk7XG4gICAgdGhpcy50dGwgPSBvcHRzLnR0bCA/PyBJbmZpbml0eTtcbiAgICB0aGlzLmRpc3Bvc2UgPSBvcHRzLmRpc3Bvc2UgPz8gKCgpID0+IHt9KTtcbiAgICB0aGlzLmRpc3Bvc2VPblVwZGF0ZSA9IG9wdHMuZGlzcG9zZU9uVXBkYXRlID8/IHRydWU7XG4gICAgdGhpcy5ldmljdGlvblBvbGljeSA9IG9wdHMuZXZpY3Rpb25Qb2xpY3kgPz8gQ2FjaGVFdmljdGlvblBvbGljaWVzLkxSVTtcbiAgICB0aGlzLmVudHJ5U2l6ZSA9IG9wdHMuZW50cnlTaXplID8/ICgoKSA9PiAxKTtcbiAgICB0aGlzLnN0YWxlID0gb3B0cy5zdGFsZSA/PyBmYWxzZTtcbiAgICB0aGlzLnJlc2V0VFRMID0gb3B0cy5yZXNldFRUTCA/PyB0cnVlO1xuICB9XG5cbiAgc2V0KFxuICAgIGtleTogSyxcbiAgICB2YWx1ZTogVixcbiAgICB7IHR0bCA9IEluZmluaXR5IH06IFBhcnRpYWw8Q2FjaGVTZXRPcHRpb25zPiA9IHt9XG4gICk6IFYgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGluc2VydGVkID0gbmV3IFRpbWVzdGFtcCgpO1xuICAgIGNvbnN0IHRvdWNoZWQgPSBuZXcgVGltZXN0YW1wKCk7XG4gICAgY29uc3QgbHJ1Tm9kZSA9IG5ldyBOb2RlPEVudHJ5PFY+PigpO1xuICAgIGNvbnN0IGluc05vZGUgPSBuZXcgTm9kZTxFbnRyeTxWPj4oKTtcblxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgdHRsLFxuICAgICAgdmFsdWUsXG4gICAgICBpbnNlcnRlZCxcbiAgICAgIHRvdWNoZWQsXG4gICAgICBscnVOb2RlLFxuICAgICAgaW5zTm9kZSxcbiAgICB9O1xuICAgIGxydU5vZGUuZGF0YSA9IGVudHJ5O1xuICAgIGluc05vZGUuZGF0YSA9IGVudHJ5O1xuXG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgIGlmIChwcmV2ICYmIHRoaXMuZGlzcG9zZU9uVXBkYXRlKSB7XG4gICAgICAvLyBOT1RFOiBbUEpdIHNpbmNlIHB1c2hpbmcgYW4gZXhpc3Rpbmcgbm9kZSBhbHNvIHJlbW92ZXMgaXQsIHdlXG4gICAgICAvLyBjYW4gYXNzdW1lIHRoYXQgaGFwcGVucyBiZWxvdy5cbiAgICAgIHRoaXMuZGlzcG9zZShrZXksIHByZXYudmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmV2aWN0KHRoaXMuZW50cnlTaXplKGVudHJ5KSk7XG5cbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBlbnRyeSk7XG4gICAgdGhpcy5scnUucHVzaE5vZGUobHJ1Tm9kZSk7XG4gICAgdGhpcy5pbnMucHVzaE5vZGUoaW5zTm9kZSk7XG5cbiAgICByZXR1cm4gcHJldj8udmFsdWU7XG4gIH1cblxuICBnZXQoXG4gICAga2V5OiBLLFxuICAgIHtcbiAgICAgIHBlZWsgPSBmYWxzZSxcbiAgICAgIGVudHJ5OiByZXR1cm5FbnRyeSA9IGZhbHNlLFxuICAgICAgc3RhbGUgPSBmYWxzZSxcbiAgICB9OiBQYXJ0aWFsPERlZmF1bHRBZGFwdGVyR2V0T3B0aW9ucz4gPSB7fVxuICApOiBWIHwgRW50cnk8Vj4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHRzID0gdGhpcy5yZXNldFRUTCA/IGVudHJ5Lmluc2VydGVkIDogZW50cnkudG91Y2hlZDtcbiAgICBjb25zdCB0dGwgPSBlbnRyeS50dGwgPyBlbnRyeS50dGwgOiB0aGlzLnR0bDtcbiAgICBpZiAodHMuaGFzUGFzc2VkKHR0bCkpIHtcbiAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICByZXR1cm4gc3RhbGUgPyBlbnRyeS52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFwZWVrKSB7XG4gICAgICB0aGlzLnRvdWNoKGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuXG4gIGhhcyhrZXk6IEssIHsgcGVlayA9IGZhbHNlIH06IFBhcnRpYWw8Q2FjaGVIYXNPcHRpb25zPiA9IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBlZWspIHtcbiAgICAgIHRoaXMudG91Y2goZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZGVsKGtleTogSywgb3B0czogUGFydGlhbDxDYWNoZURlbE9wdGlvbnM+ID0ge30pOiBWIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2Uoa2V5LCBlbnRyeSk7XG4gICAgdGhpcy5scnUucmVtb3ZlTm9kZShlbnRyeS5scnVOb2RlKTtcbiAgICB0aGlzLmlucy5yZW1vdmVOb2RlKGVudHJ5Lmluc05vZGUpO1xuICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxuXG4gIGFzZXQoXG4gICAga2V5OiBLLFxuICAgIHZhbHVlOiBWLFxuICAgIG9wdHM6IFBhcnRpYWw8Q2FjaGVTZXRPcHRpb25zPiA9IHt9XG4gICk6IFByb21pc2U8ViB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZXQoa2V5LCB2YWx1ZSwgb3B0cykpO1xuICB9XG5cbiAgYWdldChcbiAgICBrZXk6IEssXG4gICAgb3B0czogUGFydGlhbDxEZWZhdWx0QWRhcHRlckdldE9wdGlvbnM+ID0ge31cbiAgKTogUHJvbWlzZTxWIHwgRW50cnk8Vj4gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2V0KGtleSwgb3B0cykpO1xuICB9XG5cbiAgYWhhcyhrZXk6IEssIG9wdHM6IFBhcnRpYWw8Q2FjaGVIYXNPcHRpb25zPiA9IHt9KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmhhcyhrZXksIG9wdHMpKTtcbiAgfVxuXG4gIGFkZWwoa2V5OiBLLCBvcHRzOiBQYXJ0aWFsPENhY2hlRGVsT3B0aW9ucz4gPSB7fSk6IFByb21pc2U8ViB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kZWwoa2V5LCBvcHRzKSk7XG4gIH1cblxuICB0b3VjaChlbnRyeTogRW50cnk8Vj4pOiB2b2lkIHtcbiAgICBlbnRyeS50b3VjaGVkID0gbmV3IFRpbWVzdGFtcCgpO1xuICAgIHRoaXMubHJ1LnB1c2hOb2RlKGVudHJ5LmxydU5vZGUpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBldmljdChzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyAuLi5cbiAgfVxufVxuIl19