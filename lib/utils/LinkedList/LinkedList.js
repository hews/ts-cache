"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _LinkedListIterator = _interopRequireDefault(require("./LinkedListIterator"));

var _LinkedListNode = _interopRequireDefault(require("./LinkedListNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// A utility type assertion function for type guarding below.
//
function isIterable(v) {
  return typeof v !== 'string' && typeof v[Symbol.iterator] === 'function';
} // A simple, typed, doubly-linked list implementation included to allow
// us to build the LRU linked list for the default MemoryStore
// datamapper. This is also exported to allow an including library to
// build its own, more specific storage implementation, but with a (now)
// off-the-shelf linked list implementation.
//
// It's included to allow us to keep our no-dependencies cool. Based on
// {@link https://github.com/isaacs/yallist}.
//


class LinkedList {
  constructor(iterable) {
    _defineProperty(this, "head", undefined);

    _defineProperty(this, "tail", undefined);

    _defineProperty(this, "length", 0);

    if (iterable) {
      // NOTE: [PJ] not utilizing iterable for portability.
      const arr = Array.from(iterable);

      for (let i = 0, len = arr.length; i < len; i++) {
        this.push(arr[i]);
      }
    }
  }

  pushNode(node) {
    if (node.list) {
      node.list.removeNode(node);
    }

    node.list = this;
    const {
      tail
    } = this;
    node.prev = tail;

    if (tail) {
      tail.next = node;
    }

    this.tail = node;

    if (!this.head) {
      this.head = node;
    }

    this.length += 1;
  }

  unshiftNode(node) {
    if (node.list) {
      node.list.removeNode(node);
    }

    node.list = this;
    const {
      head
    } = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length += 1;
  }

  removeNode(node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }

    const {
      next
    } = node;
    const {
      prev
    } = node;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.next = undefined;
    node.prev = undefined;
    node.list = undefined;
    this.length -= 1;
  }

  push(data) {
    if (isIterable(data)) {
      // NOTE: [PJ] not utilizing iterable for portability.
      const arr = Array.from(data);

      for (let i = 0, len = arr.length; i < len; i++) {
        this.push(arr[i]);
      }

      return;
    }

    this.pushNode(new _LinkedListNode.default({
      data
    }));
  }

  unshift(data) {
    if (isIterable(data)) {
      // NOTE: [PJ] not utilizing iterable for portability.
      const arr = Array.from(data);

      for (let i = 0, len = arr.length; i < len; i++) {
        this.unshift(arr[i]);
      }

      return;
    }

    this.unshiftNode(new _LinkedListNode.default({
      data
    }));
  }

  pop() {
    if (this.tail === undefined) {
      return undefined;
    }

    const {
      data
    } = this.tail;
    this.removeNode(this.tail);
    return data;
  }

  shift() {
    if (this.head === undefined) {
      return undefined;
    }

    const {
      data
    } = this.head;
    this.removeNode(this.head);
    return data;
  }

  get iterator() {
    return new _LinkedListIterator.default(this);
  }

}

exports.default = LinkedList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9MaW5rZWRMaXN0L0xpbmtlZExpc3QudHMiXSwibmFtZXMiOlsiaXNJdGVyYWJsZSIsInYiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkxpbmtlZExpc3QiLCJjb25zdHJ1Y3RvciIsIml0ZXJhYmxlIiwidW5kZWZpbmVkIiwiYXJyIiwiQXJyYXkiLCJmcm9tIiwiaSIsImxlbiIsImxlbmd0aCIsInB1c2giLCJwdXNoTm9kZSIsIm5vZGUiLCJsaXN0IiwicmVtb3ZlTm9kZSIsInRhaWwiLCJwcmV2IiwibmV4dCIsImhlYWQiLCJ1bnNoaWZ0Tm9kZSIsIkVycm9yIiwiZGF0YSIsIk5vZGUiLCJ1bnNoaWZ0IiwicG9wIiwic2hpZnQiLCJMaXN0SXRlcmF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFJQTs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBLFNBQVNBLFVBQVQsQ0FBdUJDLENBQXZCLEVBQTZEO0FBQzNELFNBQ0UsT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFDQSxPQUFRQSxDQUFELENBQW1CQyxNQUFNLENBQUNDLFFBQTFCLENBQVAsS0FBK0MsVUFGakQ7QUFJRCxDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDZSxNQUFNQyxVQUFOLENBQXNEO0FBT25FQyxFQUFBQSxXQUFXLENBQUNDLFFBQUQsRUFBeUI7QUFBQSxrQ0FObEJDLFNBTWtCOztBQUFBLGtDQUpsQkEsU0FJa0I7O0FBQUEsb0NBRm5CLENBRW1COztBQUNsQyxRQUFJRCxRQUFKLEVBQWM7QUFDWjtBQUNBLFlBQU1FLEdBQUcsR0FBR0MsS0FBSyxDQUFDQyxJQUFOLENBQVdKLFFBQVgsQ0FBWjs7QUFDQSxXQUFLLElBQUlLLENBQUMsR0FBRyxDQUFSLEVBQVdDLEdBQUcsR0FBR0osR0FBRyxDQUFDSyxNQUExQixFQUFrQ0YsQ0FBQyxHQUFHQyxHQUF0QyxFQUEyQ0QsQ0FBQyxFQUE1QyxFQUFnRDtBQUM5QyxhQUFL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QUosR0FBZ0M7QUFDOUIsV0FBTyxJQUFJMkIsMkJBQUosQ0FBb0IsSUFBcEIsQ0FBUDtBQUNEOztBQWhJa0UiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246XG4gICAgICBbXCJlcnJvclwiLCB7IFwicHJvcHNcIjogdHJ1ZSwgXCJpZ25vcmVQcm9wZXJ0eU1vZGlmaWNhdGlvbnNGb3JcIjogW1wibm9kZVwiXSB9XSAqL1xuXG5pbXBvcnQgeyBMaW5rZWRMaXN0SW50ZXJmYWNlLCBMaW5rZWRMaXN0Tm9kZUludGVyZmFjZSBhcyBOb2RlSSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IExpc3RJdGVyYXRvciBmcm9tICcuL0xpbmtlZExpc3RJdGVyYXRvcic7XG5pbXBvcnQgTm9kZSBmcm9tICcuL0xpbmtlZExpc3ROb2RlJztcblxuLy8gQSB1dGlsaXR5IHR5cGUgYXNzZXJ0aW9uIGZ1bmN0aW9uIGZvciB0eXBlIGd1YXJkaW5nIGJlbG93LlxuLy9cbmZ1bmN0aW9uIGlzSXRlcmFibGU8VD4odjogVCB8IEl0ZXJhYmxlPFQ+KTogdiBpcyBJdGVyYWJsZTxUPiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgIT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mICh2IGFzIEl0ZXJhYmxlPFQ+KVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbi8vIEEgc2ltcGxlLCB0eXBlZCwgZG91Ymx5LWxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uIGluY2x1ZGVkIHRvIGFsbG93XG4vLyB1cyB0byBidWlsZCB0aGUgTFJVIGxpbmtlZCBsaXN0IGZvciB0aGUgZGVmYXVsdCBNZW1vcnlTdG9yZVxuLy8gZGF0YW1hcHBlci4gVGhpcyBpcyBhbHNvIGV4cG9ydGVkIHRvIGFsbG93IGFuIGluY2x1ZGluZyBsaWJyYXJ5IHRvXG4vLyBidWlsZCBpdHMgb3duLCBtb3JlIHNwZWNpZmljIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24sIGJ1dCB3aXRoIGEgKG5vdylcbi8vIG9mZi10aGUtc2hlbGYgbGlua2VkIGxpc3QgaW1wbGVtZW50YXRpb24uXG4vL1xuLy8gSXQncyBpbmNsdWRlZCB0byBhbGxvdyB1cyB0byBrZWVwIG91ciBuby1kZXBlbmRlbmNpZXMgY29vbC4gQmFzZWQgb25cbi8vIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL3lhbGxpc3R9LlxuLy9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtlZExpc3Q8VD4gaW1wbGVtZW50cyBMaW5rZWRMaXN0SW50ZXJmYWNlPFQ+IHtcbiAgaGVhZD86IE5vZGVJPFQ+ID0gdW5kZWZpbmVkO1xuXG4gIHRhaWw/OiBOb2RlSTxUPiA9IHVuZGVmaW5lZDtcblxuICBsZW5ndGg6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoaXRlcmFibGU/OiBJdGVyYWJsZTxUPikge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgLy8gTk9URTogW1BKXSBub3QgdXRpbGl6aW5nIGl0ZXJhYmxlIGZvciBwb3J0YWJpbGl0eS5cbiAgICAgIGNvbnN0IGFyciA9IEFycmF5LmZyb20oaXRlcmFibGUpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdXNoTm9kZShub2RlOiBOb2RlSTxUPik6IHZvaWQge1xuICAgIGlmIChub2RlLmxpc3QpIHtcbiAgICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBub2RlLmxpc3QgPSB0aGlzO1xuXG4gICAgY29uc3QgeyB0YWlsIH0gPSB0aGlzO1xuICAgIG5vZGUucHJldiA9IHRhaWw7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gICAgfVxuICAgIHRoaXMudGFpbCA9IG5vZGU7XG5cbiAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgfVxuXG4gIHVuc2hpZnROb2RlKG5vZGU6IE5vZGVJPFQ+KTogdm9pZCB7XG4gICAgaWYgKG5vZGUubGlzdCkge1xuICAgICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGUubGlzdCA9IHRoaXM7XG5cbiAgICBjb25zdCB7IGhlYWQgfSA9IHRoaXM7XG4gICAgbm9kZS5uZXh0ID0gaGVhZDtcbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5wcmV2ID0gbm9kZTtcbiAgICB9XG4gICAgdGhpcy5oZWFkID0gbm9kZTtcblxuICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSAxO1xuICB9XG5cbiAgcmVtb3ZlTm9kZShub2RlOiBOb2RlSTxUPik6IHZvaWQge1xuICAgIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBuZXh0IH0gPSBub2RlO1xuICAgIGNvbnN0IHsgcHJldiB9ID0gbm9kZTtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICAgIH1cblxuICAgIG5vZGUubmV4dCA9IHVuZGVmaW5lZDtcbiAgICBub2RlLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgbm9kZS5saXN0ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5sZW5ndGggLT0gMTtcbiAgfVxuXG4gIHB1c2goZGF0YTogVCB8IEl0ZXJhYmxlPFQ+KTogdm9pZCB7XG4gICAgaWYgKGlzSXRlcmFibGU8VD4oZGF0YSkpIHtcbiAgICAgIC8vIE5PVEU6IFtQSl0gbm90IHV0aWxpemluZyBpdGVyYWJsZSBmb3IgcG9ydGFiaWxpdHkuXG4gICAgICBjb25zdCBhcnIgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wdXNoTm9kZShuZXcgTm9kZSh7IGRhdGEgfSkpO1xuICB9XG5cbiAgdW5zaGlmdChkYXRhOiBUIHwgSXRlcmFibGU8VD4pOiB2b2lkIHtcbiAgICBpZiAoaXNJdGVyYWJsZTxUPihkYXRhKSkge1xuICAgICAgLy8gTk9URTogW1BKXSBub3QgdXRpbGl6aW5nIGl0ZXJhYmxlIGZvciBwb3J0YWJpbGl0eS5cbiAgICAgIGNvbnN0IGFyciA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMudW5zaGlmdChhcnJbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2hpZnROb2RlKG5ldyBOb2RlKHsgZGF0YSB9KSk7XG4gIH1cblxuICBwb3AoKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudGFpbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXMudGFpbDtcbiAgICB0aGlzLnJlbW92ZU5vZGUodGhpcy50YWlsKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHNoaWZ0KCk6IFQgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLmhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLmhlYWQ7XG4gICAgdGhpcy5yZW1vdmVOb2RlKHRoaXMuaGVhZCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBnZXQgaXRlcmF0b3IoKTogTGlzdEl0ZXJhdG9yPFQ+IHtcbiAgICByZXR1cm4gbmV3IExpc3RJdGVyYXRvcjxUPih0aGlzKTtcbiAgfVxufVxuIl19